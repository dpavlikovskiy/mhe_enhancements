/**
/// Utility functions ///
**/

importPackage (dw.customer);
importPackage (dw.order);
importPackage (dw.system);
importPackage (dw.util);
importPackage (dw.web);

importScript ('Bronto/API.ds');

function getPackageLimit () : Number {
	
	try	{
		var maxPackageSize = getCustomPreferenceValue("BrontoConversionPackageMaxSize");
		if ( null != maxPackageSize ){
			return parseInt( maxPackageSize );
		}
	} catch (e) {
    	handleError(e, 'getPackageLimit');
    }	
}

function queryOrders () : SeekableIterator {

	try {
		var orderIterator : SeekableIterator;
		var timeShift : Number = parseInt( getCustomPreferenceValue("BrontoConversionQueryPeriod") );
		var date : Date = new Date();
		var minutes : Number = date.getMinutes();
		date.setMinutes(minutes - timeShift);
		var query : String = "creationDate > {0}";
		orderIterator = OrderMgr.queryOrders(query, "orderNo asc", date);
		return orderIterator;
	} catch (e) {
		handleError(e, 'queryOrders');
	}
}

/*
Active Data is regenerated by Demandware once a day, but the ussue is that no one know certain time, when it happenes. 
*/
function queryPreviousDayOrders () : SeekableIterator {
	
	try {
		var startDate : Date = new Date();
		var endDate : Date = new Date();
		startDate.setDate(startDate.getDate()-7); // set -7 for testing purposes, and -2 for production
		startDate.setHours(startDate.getHours()-1);
		endDate.setDate(endDate.getDate()-0);   // set -0 for testing purposes, and -1 for production

		var query : String = "creationDate > {0} AND creationDate < {1}";

		var orderIterator : SeekableIterator = 
			OrderMgr.queryOrders(query, "orderNo asc", startDate, endDate);
		return orderIterator;		
	} catch (e) {
		handleError(e, "queryPreviousDayOrders");
	}
}

function getUniqueCustomers (orders : Array) {
	try {
		var customers : Array = getCustomers(orders);
		return eliminateDuplicates(customers);
	} catch (e) {
		handleError(e, "getUniqueCustomers");	
	}
}

function getCustomers (orders : Array) {
	var customers : Array = [];
	try {
		for (let i = 0; i < orders.length; i++) {
			var order : Order = OrderMgr.getOrder(orders[i]);
			customers.push(order.customerNo);
		}
	   return customers;
	} catch (e) {
		handleError(e, "getCustomers");	
	}
}

function getOrderIdArray (orderIterator : SeekableIterator, limit : Number) {
	
	var arr : Array = [],
			i = 0;
	limit = limit || Number.MAX_VALUE;
	try {
		if (orderIterator.count > 0) {
			while (orderIterator.hasNext() && (i < limit) ) {
				var order : Order = orderIterator.next();
				arr.push(order.orderNo);
				i++;
			}	
		}
	   return arr;
   	} catch (e) {
		handleError(e, 'getOrderIdArray');
	}
}

function getCheckoutType (order : Order) {
	var checkoutType : String = "guest";
	try {
		var registered : Boolean = order.customer.registered; 
		var hasPreferredAddress : Boolean = false;
		if (order.customer.profile && order.customer.addressBook.preferredAddress) {
			hasPreferredAddress =  true;
		}
		switch (true) {
			case (registered && hasPreferredAddress):
				checkoutType = "normal";
				break;
			case (registered):
				checkoutType = "no_adress";
				break;
			default:
				checkoutType = "guest";
				break;	
		}
	   return 	checkoutType;
	} catch (e) {
    	handleError(e, 'getPackageLimit');
    }	
}

function prepareContacts (orders : Array, fieldsIdMap : HashMap, map : HashMap) {
	
	var contacts : Array = [];			
	try {
			for (let i=0; i < orders.length; i++) {
				
				var order : Order = OrderMgr.getOrder(orders[i]);
				var orderData = getOrderData(order);
				var checkoutType = getCheckoutType(order);
				var preparedContact : map.ref.ContactObject;
				switch (checkoutType) { 
				case "normal":
					preparedContact = getPreparedContactLight(order.customer.profile, fieldsIdMap, map, orderData);			
					break;
				case "no_adress":
					preparedContact = getPreparedContactFromOrderWithoutSavedAddress(order, fieldsIdMap, map, orderData);
					break;
				case "guest":
					preparedContact = getPreparedContactFromUnregistered(order, fieldsIdMap, map, orderData);
					break;
				default:
					preparedContact = getPreparedContactLight(order.customer.profile, fieldsIdMap, map, orderData);
				}
				contacts.push(preparedContact);
			}
		   return contacts;
	} catch (e) {
		handleError(e, 'prepareContacts');
	}	   
}

function prepareContactsForActiveData (customers : Array, fieldsIdMap : HashMap, map : HashMap) {

	var preparedContacts : Array = [];		
	try {
		for (let i=0; i < customers.length; i++) {
			var profile : Profile = CustomerMgr.getProfile(customers[i]);
			var preparedContact = getActiveDataPreparedContact(profile, fieldsIdMap, map);
			if (preparedContact) { 
				preparedContacts.push(preparedContact);	
			}
		}	
	   return preparedContacts;			
	} catch (e) {
		handleError(e, 'prepareContactsForActiveData');
	}	 
}

function getOrderData (order : Order) {
	
	var orderData : HashMap = new HashMap();
	try {
		var email : String = getCustomerEmail(order);
		orderData.put("email", email);
		orderData.put("customerName", order.customerName);
	} catch (e) {
		handleError(e, 'getOrderData');
	}		
   return orderData;
}

function eliminateDuplicates (arr : Array) {
  var i,
      len=arr.length,
      out=[],
      obj={};

  for (i=0;i<len;i++) {
    obj[arr[i]]=0;
  }
  for (i in obj) {
    out.push(i);
  }
  return out;
}

// Returns array of order numbers without conversion
function checkExistingConversions (orders : Array, conversions : Array) {
	var result : Array = [];
	// duplicate orders to result
	for (var i = 0; i < orders.length; i++) {
		result.push(orders[i]);	
	}
	try {
		// convert conversions into array with appropriate order id
		var conversionOrders : Array = [];
		if (conversions) {
			
			for (let i = 0; i < conversions.length; i++) {
				conversionOrders.push(conversions[i].orderId);
			}
			conversionOrders.sort();
		}
		var conversionOrders = eliminateDuplicates(conversionOrders);
		// than delete from result elements with existing conversions
		if (!empty(conversionOrders)) {
			for (var i = 0; i < orders.length; i++) {
				for (var j = 0; j < conversionOrders.length; j++) {
					if (orders[i] === conversionOrders[j]) {
						// conversion exist, shold delete from initial array
						var position = result.indexOf(orders[i]);
						result.splice(position, 1);
					}
				}
			}
		}
	   return result;
	} catch (e) {
		handleError(e, 'checkExistingConversions');
	}		 
}