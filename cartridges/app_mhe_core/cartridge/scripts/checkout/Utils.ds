/**
 * This script provides utility functions shared across other checkout scripts.
 * Reused script components for checkout should be contained here, while this
 * script is imported into the requiring script.
 */
importPackage( dw.customer );
importPackage( dw.order );
importPackage( dw.system );
importPackage( dw.util );
importPackage( dw.value );
importPackage( dw.web );
importPackage( dw.catalog );
var COMPLIMENTARY:String="ORDER_COMPLIMENTARY";
var REPLACEMENT:String="ORDER_REPLACEMENT";
/**
 * Calculates the amount to be payed by a non-gift certificate payment instrument based 
 * on the given basket. The method subtracts the amount of all redeemed gift certificates 
 * from the order total and returns this value.
 *
 * PJP-2000: Modified logic to use LineItemCtnr (to support both Basket and Order)
 */
function calculateNonGiftCertificateAmount( lineItemCtnr : LineItemCtnr ) 
{
	// the total redemption amount of all gift certificate payment instruments in the basket
	var giftCertTotal : Money = new Money( 0.0, lineItemCtnr.currencyCode );

	// get the list of all gift certificate payment instruments 
	var gcPaymentInstrs : Collection = lineItemCtnr.getGiftCertificatePaymentInstruments();
	var iter : Iterator = gcPaymentInstrs.iterator();
	var orderPI : OrderPaymentInstrument = null;

	// sum the total redemption amount
	while( iter.hasNext() )
	{
		orderPI = iter.next();
		giftCertTotal = giftCertTotal.add( orderPI.getPaymentTransaction().getAmount() );
	}

	// get the order total
	var orderTotal : Money = lineItemCtnr.totalGrossPrice;

	// calculate the amount to charge for the payment instrument
	// this is the remaining open order total which has to be paid
	var amountOpen : Money = orderTotal.subtract( giftCertTotal );

	// return the open amount
	return amountOpen;
}

/**
 * Determines a unique shipment ID for shipments in the given basket
 * and the given base ID. The function appends a counter to the base ID
 * and checks the existence of the resulting ID. If the resulting ID is
 * unique this ID is returned, if not the counter is incremented and
 * checked again.
 */
function determineUniqueShipmentID( basket : Basket, baseID : String )
{
	var counter : Number = 1;
	var shipment : Shipment = null;
	var candidateID : String = baseID + "" + counter;
	while( shipment == null )
	{
		shipment = basket.getShipment(candidateID);
		if( shipment != null )
		{
			// this ID is already taken, increment the counter 
			// and try the next one
			counter++;
			candidateID = baseID + "" + counter;
			shipment = null;
		}
		else
		{
			return candidateID;
		}
	}
	
	// should never go here
	return null;
}

/**
 * Transient representation of a shipping address.
 */
function ShippingAddress()
{
	var UUID : String = null;

	var ID 			: String = null;
	var firstName 	: String = null;
	var lastName 	: String = null;
	var address1 	: String = null;
	var address2 	: String = null;
	var city 		: String = null;
	var postalCode 	: String = null;
	var stateCode 	: String = null;
	var countryCode : String = null;
	var phone 		: String = null;

	/**
	 * The UUID of the reference address. It is set when the attributes
	 * are copied from a given customer or order address and is used
	 * to preselect addresses on a per product line item base.
	 */
	var referenceAddressUUID : String = null;

	/**
	 * Copies the attributes of this address to the given order address.
	 */ 
	this.copyTo = function( toAddress : OrderAddress )
	{
		toAddress.setFirstName( this.firstName );
		toAddress.setLastName( this.lastName );
		toAddress.setAddress1( this.address1 );
		toAddress.setAddress2( this.address2 );
		toAddress.setCity( this.city );
		toAddress.setPostalCode( this.postalCode );
		toAddress.setStateCode( this.stateCode );
		toAddress.setCountryCode( this.countryCode );
		toAddress.setPhone( this.phone );
	};

	/**
	 * Copies the attributes from the given customer address or
	 * order address to this address. The function supports both
	 * copying from CustomerAddress as well as from OrderAddress.
	 */
	this.copyFrom = function( fromAddress : CustomerAddress )
	{
		// if we copy from a customer address, we set the address ID
		if( fromAddress instanceof CustomerAddress )
		{
			this.ID = fromAddress.ID;
		}
		
		this.firstName = fromAddress.firstName;
		this.lastName = fromAddress.lastName;
		this.address1 = fromAddress.address1;
		this.address2 = fromAddress.address2;
		this.city = fromAddress.city;
		this.postalCode = fromAddress.postalCode;
		this.stateCode = fromAddress.stateCode;
		this.countryCode = fromAddress.countryCode;
		this.phone = fromAddress.phone;
		
		if (fromAddress.countryCode.value != null){
			this.countryCode = fromAddress.countryCode.value;
		} else {
			this.countryCode = fromAddress.countryCode;
		}
		
		// if we copy from a customer address, we set the address ID and UUID
		if(('ID' in fromAddress) && (fromAddress instanceof CustomerAddress || (fromAddress.ID != null && fromAddress.UUID != null)) ){
			this.ID = fromAddress.ID;
			this.referenceAddressUUID = fromAddress.UUID;
		}
		
		if ('referenceAddressUUID' in fromAddress && fromAddress.referenceAddressUUID != null){
			this.referenceAddressUUID = fromAddress.referenceAddressUUID;
		}
	};
	
	/**
	*	New function for multi-shipping checkout
	*	Checks if the address already exists in an array of addresses
	*/
	this.addressExists = function (addresses : Array) : Boolean
	{
		for each (var address : Object in addresses){
			if (this.referenceAddressUUID != null && (address.referenceAddressUUID != null)){
				if (this.referenceAddressUUID.equals(address.referenceAddressUUID)){
					return true;
				}
			} else {
				if (this.firstName == address.firstName &&
					this.lastName == address.lastName &&
					this.address1 == address.address1 &&
					this.address2 == address.address2 &&
					this.city == address.city &&
					this.postalCode == address.postalCode &&
					this.stateCode == address.stateCode &&
					this.countryCode == address.countryCode &&
					this.phone == address.phone){
						return true;
					}
			}
		}
		
		return false;
	};
}

/**
 * Creates a new transient shipping address in the session dictionary.
 */
function createShippingAddress( referenceAddress : CustomerAddress )
{
	// create a new in memory address and set the UUID
	var address : Object = new ShippingAddress();
	address.UUID = UUIDUtils.createUUID();

	// get all addresses from session dictionary
	var addresses : Collection = session.custom.shippingAddresses;

	// create an empty array, if no collection was found in session dictionary
	if( addresses == null )
	{
		addresses = new ArrayList();
		session.custom.shippingAddresses = addresses;
	}

	// add the address to the collection
	addresses.add( address );

	// copy the attribute of the reference address to the transient address
	

	return address;
}

/**
 * Finds a transient shipping address in the session dictionary
 * and returns the found address.
 */
function findShippingAddress( uuid : String )
{
	// check if uuid is set
	if( empty(uuid) )
	{
		return null;
	}

	// get all addresses from session dictionary
	var addresses : Collection = session.custom.shippingAddresses;

	// check if there are addresses at all
	if( addresses == null || addresses.size() == 0 )
	{
		return null;
	}

	// find the address
	for(var i=0; i<addresses.size(); i++)
	{
		if( uuid.equals(addresses[i].UUID) )
		{
			return addresses[i];
		}	
	}

	return null;
}

/**
 * Removes a transient shipping address from the session dictionary.
 */
function removeShippingAddress( shippingAddress : Object )
{
	// check if shippingAddress is set
	if( empty(shippingAddress) )
	{
		return;
	}

	// get all addresses from session dictionary
	var addresses : Collection = session.custom.shippingAddresses;

	// check if there are addresses at all
	if( addresses == null || addresses.size() == 0 )
	{
		return;
	}

	// remove the object from the collection
	addresses.remove( shippingAddress );

	return;
}

/** 
 * Determines if the basket already contains payment 
 * instruments of the given payment method and removes them from the basket.
 */
function removeExistingPaymentInstruments( lineItemCtnr : LineItemCtnr, method : String )
{
	// get all credit card payment instruments
	var ccPaymentInstrs : Collection = lineItemCtnr.getPaymentInstruments( method );
	var iter : Iterator = ccPaymentInstrs.iterator();
	var existingPI : OrderPaymentInstrument = null;

	// remove them
	while( iter.hasNext() )
	{
		existingPI = iter.next();
		lineItemCtnr.removePaymentInstrument( existingPI );
	}
}

/**
*	New function for multi-shipping checkout
*	Adds a new address to the JSON object of the sessionAddressBook attribute
*/
function addAddressToJSON(jsonAddressBook : String, referenceAddress : Object) : String {
	var address : Object = new ShippingAddress();
	var jsonObj : Object = new Object();
	var log : Log = Logger.getLogger("multishipping");
	
	if (referenceAddress != null){
		// Try to parse incoming JSON string
		try {
			if (jsonAddressBook != null){
				jsonObj = JSON.parse(jsonAddressBook);
			}
		} catch (error){
			log.error(Resource.msgf("multishipping.error.parsejson", "checkout", null, error));
		}
		
		// Check if JSON object already has addresses
		if (!(jsonObj.addresses instanceof Array)){
			jsonObj.addresses = new Array();
		}
		
		address.UUID = UUIDUtils.createUUID();
		address.copyFrom(referenceAddress);
		
		// Add address if not already existing
		if (!address.addressExists(jsonObj.addresses)){
			jsonObj.addresses.push(address);
		}
	}
	
	return JSON.stringify(jsonObj);
}

/**
*	New function for multi-shipping checkout
*	Updates an address in the JSON sessionAddressBookAttribute
*/
function updateAddressInJSON(jsonAddressBook : String, referenceAddress : Object, originalUUID : String) : String {
	var newAddress : Object = new ShippingAddress();
	var jsonObj : Object = new Object();
	var addresses : Array = new Array();
	var log : Log = Logger.getLogger("multishipping");
	
	if (referenceAddress != null && jsonAddressBook != null && originalUUID != null){
		try {
			jsonObj = JSON.parse(jsonAddressBook);
		} catch (error){
			log.error(Resource.msgf("multishipping.error.parsejson", "checkout", null, error));
			return jsonAddressBook;
		}
		
		newAddress.copyFrom(referenceAddress);
		addresses = jsonObj.addresses;
		
		for (var i = 0; i < addresses.length; i++){
			if (addresses[i].UUID == originalUUID){
				newAddress.UUID = addresses[i].UUID;
				newAddress.ID = addresses[i].ID;
				newAddress.referenceAddressUUID = addresses[i].referenceAddressUUID;
				jsonObj.addresses[i] = newAddress;
			}
		}
		
		return JSON.stringify(jsonObj);
	}
}

/**
*	Returns the addresses stored in the sessionAddressBook attribute as ArrayList.
*/
function getSessionAddresses(basket : Basket) : ArrayList {
	var sessionAddressBookObj : Object = new Object();
	var sessionAddressBook : String = new String();
	var sessionAddresses : ArrayList = new ArrayList();
	var log : Log = Logger.getLogger("multishipping");
	
	if (!empty(basket.describe().getCustomAttributeDefinition('sessionAddressBook'))){
		sessionAddressBook = basket.custom.sessionAddressBook;
	
		// Session addresses availability check
		if (sessionAddressBook != null){
			try {
				sessionAddressBookObj = JSON.parse(sessionAddressBook);
				sessionAddresses.add(sessionAddressBookObj.addresses);
			} catch (error){
				log.error(Resource.msgf("multishipping.error.parsejson", "checkout", null, error));
				return null;
			}
		}
		
		return sessionAddresses;
	}
	
	return null;
}

/**
*	Helper object to store ProductLineItem information for each quantity.
*	Used in Multi-Shipping Checkout to save creation of new PLIs for each quantity.
*/
function QuantityLineItem(){
	var productID : String = null;
	var lineItemText : String = null;
	var quantity : Quantity = null;
	var pliUUID : String = null;
	var optionID : String = null;
}

function getTitleMap () : Map {
	//Get the title values from properties files 
	var titleMap : dw.util.LinkedHashMap = new dw.util.LinkedHashMap();
	var keyDispVal : String = "title.displayValue";
	var keyVal : String = "title.value";
	var exitLoop : Boolean = false;

	var i : Number = 1;	
	while (!exitLoop){						 
		var dispVal : String = dw.web.Resource.msg(keyDispVal+i,'forms',null);
		var val : String = dw.web.Resource.msg(keyVal+i,'forms',null);
								
		if (empty(dispVal) || dispVal.equals(keyDispVal+i)) {
			exitLoop = true;
		} else {
			if (empty(val) || val.equals(keyVal+i)) {
				val = dispVal;
			}					
			titleMap.put(val, dispVal);
		}		 
		//Increase value of 'i' by 1
		i = i + 1;						 
	}
	return titleMap;
}

function getSalutationMap () : Map {
	//Get the title values from properties files 
	var salutationMap : dw.util.LinkedHashMap = new dw.util.LinkedHashMap();
	var keyDispVal : String = "salutation.displayValue";
	var keyVal : String = "salutation.value";
	var exitLoop : Boolean = false;

	var i : Number = 1;	
	while (!exitLoop){						 
		var dispVal : String = dw.web.Resource.msg(keyDispVal+i,'forms',null);
		var val : String = dw.web.Resource.msg(keyVal+i,'forms',null);
								
		if (empty(dispVal) || dispVal.equals(keyDispVal+i)) {
			exitLoop = true;
		} else {
			if (empty(val) || val.equals(keyVal+i)) {
				val = dispVal;
			}					
			salutationMap.put(val, dispVal);
		}		 
		//Increase value of 'i' by 1
		i = i + 1;						 
	}
	return salutationMap;
}

/**
* Function to convert date into string format
*
*/

function convertToFullDate(date: Date): String
{
var dateString ;
var datesuffix;
var calendar:Calendar=new Calendar(new Date(date));
var suffix = new Array();
suffix[0] = "th";
suffix[1] = "st";
suffix[2] = "nd";
suffix[3] = "rd";
var dd = calendar.get(Calendar.DATE);

    if ((dd >= 11 && dd <= 13) || (dd % 10 > 3)){
       datesuffix = suffix[0];
    }   
    else 
       datesuffix = suffix[dd % 10];
       dateString = StringUtils.formatCalendar(calendar, "MMMM yyyy");
       dateString = dd + datesuffix + " " + dateString;

   return dateString;
}

//Get the order Map   
function getOrderMap (customer:Customer) : Map {
	//Get the title values from properties files 
	  var titleMap:LinkedHashMap=new LinkedHashMap();  
	 try{
     
  	   var query : String = "";
  	   var orderIterator : SeekableIterator =null;
  	   
         query = "customerNo = {0} AND shippingStatus ={1}";
         orderIterator  = OrderMgr.queryOrders(query, "creationDate desc",customer.profile.customerNo,Order.SHIPPING_STATUS_SHIPPED);
      
		//Iterate all order product line items 
		var order : Order = null;
		var productLineItems : Iterator=null;
	    if (!empty(orderIterator)){
			while (orderIterator.hasNext())				
			{
				order = orderIterator.next();
				//exclude complimentory and replaced order
			    if(!isComplimentaryOrder(order) && empty(order.custom.replacedOrderNumber)){
			      titleMap.put(order.orderNo,order.orderNo +" ..... "+ StringUtils.formatCalendar(new Calendar(order.creationDate), "dd MMMM yyyy"));	
			    }
			}
		}
	   
	}catch(ex){
		 var msg:String=ex.message;
	}
	return titleMap;
}

//Rerun true if an order payment method is ORDER_COMPLIMENTARY.
function isComplimentaryOrder (order:Order) : boolean {
	   while(order.getPaymentInstruments().iterator() != null  && order.getPaymentInstruments().iterator().hasNext()){
	    if(order.getPaymentInstruments().iterator().next().paymentMethod.equalsIgnoreCase(COMPLIMENTARY)){
	    	return true;
		  }else{
	      return false;
	    }
	 	break;
	  }
}

function isReplacementAndCancelledOrder(order:Order) : boolean {
	   while(order.getPaymentInstruments().iterator() != null  && order.getPaymentInstruments().iterator().hasNext()){
	    if(order.getPaymentInstruments().iterator().next().paymentMethod.equalsIgnoreCase(REPLACEMENT)){
	    	if(order.status==Order.ORDER_STATUS_CANCELLED){
	    	  return true;
	    	}else{
	    	  return false;
	    	}
		  }else{
	      return false;
	    }
	 	break;
	  }
}